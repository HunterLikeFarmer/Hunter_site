import {
  require_react_dom
} from "./chunk-SB5BK2J2.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-N6MYFXC3.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r(e2) {
  var t, f, n = "";
  if ("string" == typeof e2 || "number" == typeof e2) n += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) for (t = 0; t < e2.length; t++) e2[t] && (f = r(e2[t])) && (n && (n += " "), n += f);
  else for (t in e2) e2[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e2, t, f = 0, n = ""; f < arguments.length; ) (e2 = arguments[f++]) && (t = r(e2)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/react-draggable/build/cjs/utils/shims.js
var require_shims = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/shims.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dontSetMe = dontSetMe;
    exports.findInArray = findInArray;
    exports.int = int;
    exports.isFunction = isFunction;
    exports.isNum = isNum3;
    function findInArray(array, callback) {
      for (let i2 = 0, length = array.length; i2 < length; i2++) {
        if (callback.apply(callback, [array[i2], i2, array])) return array[i2];
      }
    }
    function isFunction(func) {
      return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
    }
    function isNum3(num) {
      return typeof num === "number" && !isNaN(num);
    }
    function int(a) {
      return parseInt(a, 10);
    }
    function dontSetMe(props, propName, componentName) {
      if (props[propName]) {
        return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/getPrefix.js
var require_getPrefix = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/getPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.browserPrefixToKey = browserPrefixToKey;
    exports.browserPrefixToStyle = browserPrefixToStyle;
    exports.default = void 0;
    exports.getPrefix = getPrefix;
    var prefixes = ["Moz", "Webkit", "O", "ms"];
    function getPrefix() {
      var _window$document;
      let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      if (typeof window === "undefined") return "";
      const style2 = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;
      if (!style2) return "";
      if (prop in style2) return "";
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        if (browserPrefixToKey(prop, prefixes[i2]) in style2) return prefixes[i2];
      }
      return "";
    }
    function browserPrefixToKey(prop, prefix) {
      return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
    }
    function browserPrefixToStyle(prop, prefix) {
      return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
    }
    function kebabToTitleCase(str) {
      let out = "";
      let shouldCapitalize = true;
      for (let i2 = 0; i2 < str.length; i2++) {
        if (shouldCapitalize) {
          out += str[i2].toUpperCase();
          shouldCapitalize = false;
        } else if (str[i2] === "-") {
          shouldCapitalize = true;
        } else {
          out += str[i2];
        }
      }
      return out;
    }
    var _default = exports.default = getPrefix();
  }
});

// node_modules/react-draggable/build/cjs/utils/domFns.js
var require_domFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/domFns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addClassName = addClassName;
    exports.addEvent = addEvent;
    exports.addUserSelectStyles = addUserSelectStyles;
    exports.createCSSTransform = createCSSTransform;
    exports.createSVGTransform = createSVGTransform;
    exports.getTouch = getTouch;
    exports.getTouchIdentifier = getTouchIdentifier;
    exports.getTranslation = getTranslation;
    exports.innerHeight = innerHeight;
    exports.innerWidth = innerWidth;
    exports.matchesSelector = matchesSelector;
    exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
    exports.offsetXYFromParent = offsetXYFromParent;
    exports.outerHeight = outerHeight;
    exports.outerWidth = outerWidth;
    exports.removeClassName = removeClassName;
    exports.removeEvent = removeEvent;
    exports.removeUserSelectStyles = removeUserSelectStyles;
    var _shims = require_shims();
    var _getPrefix = _interopRequireWildcard(require_getPrefix());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var matchesSelectorFunc = "";
    function matchesSelector(el, selector) {
      if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
          return (0, _shims.isFunction)(el[method]);
        });
      }
      if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
      return el[matchesSelectorFunc](selector);
    }
    function matchesSelectorAndParentsTo(el, selector, baseNode) {
      let node = el;
      do {
        if (matchesSelector(node, selector)) return true;
        if (node === baseNode) return false;
        node = node.parentNode;
      } while (node);
      return false;
    }
    function addEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.addEventListener) {
        el.addEventListener(event, handler, options);
      } else if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
      } else {
        el["on" + event] = handler;
      }
    }
    function removeEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
      } else if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
      } else {
        el["on" + event] = null;
      }
    }
    function outerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height += (0, _shims.int)(computedStyle.borderTopWidth);
      height += (0, _shims.int)(computedStyle.borderBottomWidth);
      return height;
    }
    function outerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width += (0, _shims.int)(computedStyle.borderLeftWidth);
      width += (0, _shims.int)(computedStyle.borderRightWidth);
      return width;
    }
    function innerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height -= (0, _shims.int)(computedStyle.paddingTop);
      height -= (0, _shims.int)(computedStyle.paddingBottom);
      return height;
    }
    function innerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width -= (0, _shims.int)(computedStyle.paddingLeft);
      width -= (0, _shims.int)(computedStyle.paddingRight);
      return width;
    }
    function offsetXYFromParent(evt, offsetParent, scale) {
      const isBody = offsetParent === offsetParent.ownerDocument.body;
      const offsetParentRect = isBody ? {
        left: 0,
        top: 0
      } : offsetParent.getBoundingClientRect();
      const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
      const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
      return {
        x,
        y
      };
    }
    function createCSSTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "px");
      return {
        [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
      };
    }
    function createSVGTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "");
      return translation;
    }
    function getTranslation(_ref, positionOffset, unitSuffix) {
      let {
        x,
        y
      } = _ref;
      let translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");
      if (positionOffset) {
        const defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
        const defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
        translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
      }
      return translation;
    }
    function getTouch(e2, identifier) {
      return e2.targetTouches && (0, _shims.findInArray)(e2.targetTouches, (t) => identifier === t.identifier) || e2.changedTouches && (0, _shims.findInArray)(e2.changedTouches, (t) => identifier === t.identifier);
    }
    function getTouchIdentifier(e2) {
      if (e2.targetTouches && e2.targetTouches[0]) return e2.targetTouches[0].identifier;
      if (e2.changedTouches && e2.changedTouches[0]) return e2.changedTouches[0].identifier;
    }
    function addUserSelectStyles(doc2) {
      if (!doc2) return;
      let styleEl = doc2.getElementById("react-draggable-style-el");
      if (!styleEl) {
        styleEl = doc2.createElement("style");
        styleEl.type = "text/css";
        styleEl.id = "react-draggable-style-el";
        styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
        styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
        doc2.getElementsByTagName("head")[0].appendChild(styleEl);
      }
      if (doc2.body) addClassName(doc2.body, "react-draggable-transparent-selection");
    }
    function removeUserSelectStyles(doc2) {
      if (!doc2) return;
      try {
        if (doc2.body) removeClassName(doc2.body, "react-draggable-transparent-selection");
        if (doc2.selection) {
          doc2.selection.empty();
        } else {
          const selection = (doc2.defaultView || window).getSelection();
          if (selection && selection.type !== "Caret") {
            selection.removeAllRanges();
          }
        }
      } catch (e2) {
      }
    }
    function addClassName(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
          el.className += " ".concat(className);
        }
      }
    }
    function removeClassName(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/positionFns.js
var require_positionFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/positionFns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.canDragX = canDragX;
    exports.canDragY = canDragY;
    exports.createCoreData = createCoreData;
    exports.createDraggableData = createDraggableData;
    exports.getBoundPosition = getBoundPosition;
    exports.getControlPosition = getControlPosition;
    exports.snapToGrid = snapToGrid;
    var _shims = require_shims();
    var _domFns = require_domFns();
    function getBoundPosition(draggable, x, y) {
      if (!draggable.props.bounds) return [x, y];
      let {
        bounds
      } = draggable.props;
      bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
      const node = findDOMNode(draggable);
      if (typeof bounds === "string") {
        const {
          ownerDocument
        } = node;
        const ownerWindow = ownerDocument.defaultView;
        let boundNode;
        if (bounds === "parent") {
          boundNode = node.parentNode;
        } else {
          boundNode = ownerDocument.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
          throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        const boundNodeEl = boundNode;
        const nodeStyle = ownerWindow.getComputedStyle(node);
        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        bounds = {
          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
      }
      if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
      if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
      if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
      if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
      return [x, y];
    }
    function snapToGrid(grid, pendingX, pendingY) {
      const x = Math.round(pendingX / grid[0]) * grid[0];
      const y = Math.round(pendingY / grid[1]) * grid[1];
      return [x, y];
    }
    function canDragX(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "x";
    }
    function canDragY(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "y";
    }
    function getControlPosition(e2, touchIdentifier, draggableCore) {
      const touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e2, touchIdentifier) : null;
      if (typeof touchIdentifier === "number" && !touchObj) return null;
      const node = findDOMNode(draggableCore);
      const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
      return (0, _domFns.offsetXYFromParent)(touchObj || e2, offsetParent, draggableCore.props.scale);
    }
    function createCoreData(draggable, x, y) {
      const isStart = !(0, _shims.isNum)(draggable.lastX);
      const node = findDOMNode(draggable);
      if (isStart) {
        return {
          node,
          deltaX: 0,
          deltaY: 0,
          lastX: x,
          lastY: y,
          x,
          y
        };
      } else {
        return {
          node,
          deltaX: x - draggable.lastX,
          deltaY: y - draggable.lastY,
          lastX: draggable.lastX,
          lastY: draggable.lastY,
          x,
          y
        };
      }
    }
    function createDraggableData(draggable, coreData) {
      const scale = draggable.props.scale;
      return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
      };
    }
    function cloneBounds(bounds) {
      return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
      };
    }
    function findDOMNode(draggable) {
      const node = draggable.findDOMNode();
      if (!node) {
        throw new Error("<DraggableCore>: Unmounted during event!");
      }
      return node;
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/log.js
var require_log = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = log;
    function log() {
      if (void 0) console.log(...arguments);
    }
  }
});

// node_modules/react-draggable/build/cjs/DraggableCore.js
var require_DraggableCore = __commonJS({
  "node_modules/react-draggable/build/cjs/DraggableCore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var eventsFor = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        stop: "touchend"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        stop: "mouseup"
      }
    };
    var dragEventFor = eventsFor.mouse;
    var DraggableCore2 = class extends React2.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "dragging", false);
        _defineProperty(this, "lastX", NaN);
        _defineProperty(this, "lastY", NaN);
        _defineProperty(this, "touchIdentifier", null);
        _defineProperty(this, "mounted", false);
        _defineProperty(this, "handleDragStart", (e2) => {
          this.props.onMouseDown(e2);
          if (!this.props.allowAnyClick && typeof e2.button === "number" && e2.button !== 0) return false;
          const thisNode = this.findDOMNode();
          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
            throw new Error("<DraggableCore> not mounted on DragStart!");
          }
          const {
            ownerDocument
          } = thisNode;
          if (this.props.disabled || !(e2.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.cancel, thisNode)) {
            return;
          }
          if (e2.type === "touchstart") e2.preventDefault();
          const touchIdentifier = (0, _domFns.getTouchIdentifier)(e2);
          this.touchIdentifier = touchIdentifier;
          const position = (0, _positionFns.getControlPosition)(e2, touchIdentifier, this);
          if (position == null) return;
          const {
            x,
            y
          } = position;
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
          (0, _log.default)("calling", this.props.onStart);
          const shouldUpdate = this.props.onStart(e2, coreEvent);
          if (shouldUpdate === false || this.mounted === false) return;
          if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
          this.dragging = true;
          this.lastX = x;
          this.lastY = y;
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
        });
        _defineProperty(this, "handleDrag", (e2) => {
          const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX, deltaY = y - this.lastY;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            if (!deltaX && !deltaY) return;
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
          const shouldUpdate = this.props.onDrag(e2, coreEvent);
          if (shouldUpdate === false || this.mounted === false) {
            try {
              this.handleDragStop(new MouseEvent("mouseup"));
            } catch (err) {
              const event = document.createEvent("MouseEvents");
              event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
              this.handleDragStop(event);
            }
            return;
          }
          this.lastX = x;
          this.lastY = y;
        });
        _defineProperty(this, "handleDragStop", (e2) => {
          if (!this.dragging) return;
          const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX || 0;
            let deltaY = y - this.lastY || 0;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          const shouldContinue = this.props.onStop(e2, coreEvent);
          if (shouldContinue === false || this.mounted === false) return false;
          const thisNode = this.findDOMNode();
          if (thisNode) {
            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
          }
          (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
          this.dragging = false;
          this.lastX = NaN;
          this.lastY = NaN;
          if (thisNode) {
            (0, _log.default)("DraggableCore: Removing handlers");
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
          }
        });
        _defineProperty(this, "onMouseDown", (e2) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStart(e2);
        });
        _defineProperty(this, "onMouseUp", (e2) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStop(e2);
        });
        _defineProperty(this, "onTouchStart", (e2) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStart(e2);
        });
        _defineProperty(this, "onTouchEnd", (e2) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStop(e2);
        });
      }
      componentDidMount() {
        this.mounted = true;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
        }
      }
      componentWillUnmount() {
        this.mounted = false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          const {
            ownerDocument
          } = thisNode;
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
          if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
        }
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props, _this$props2;
        return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);
      }
      render() {
        return React2.cloneElement(React2.Children.only(this.props.children), {
          // Note: mouseMove handler is attached to document so it will still function
          // when the user drags quickly and leaves the bounds of the element.
          onMouseDown: this.onMouseDown,
          onMouseUp: this.onMouseUp,
          // onTouchStart is added on `componentDidMount` so they can be added with
          // {passive: false}, which allows it to cancel. See
          // https://developers.google.com/web/updates/2017/01/scrolling-intervention
          onTouchEnd: this.onTouchEnd
        });
      }
    };
    exports.default = DraggableCore2;
    _defineProperty(DraggableCore2, "displayName", "DraggableCore");
    _defineProperty(DraggableCore2, "propTypes", {
      /**
       * `allowAnyClick` allows dragging using any mouse button.
       * By default, we only accept the left button.
       *
       * Defaults to `false`.
       */
      allowAnyClick: _propTypes.default.bool,
      children: _propTypes.default.node.isRequired,
      /**
       * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
       * with the exception of `onMouseDown`, will not fire.
       */
      disabled: _propTypes.default.bool,
      /**
       * By default, we add 'user-select:none' attributes to the document body
       * to prevent ugly text selection during drag. If this is causing problems
       * for your app, set this to `false`.
       */
      enableUserSelectHack: _propTypes.default.bool,
      /**
       * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
       * instead of using the parent node.
       */
      offsetParent: function(props, propName) {
        if (props[propName] && props[propName].nodeType !== 1) {
          throw new Error("Draggable's offsetParent must be a DOM Node.");
        }
      },
      /**
       * `grid` specifies the x and y that dragging should snap to.
       */
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      /**
       * `handle` specifies a selector to be used as the handle that initiates drag.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable handle=".handle">
       *              <div>
       *                  <div className="handle">Click me to drag</div>
       *                  <div>This is some other content</div>
       *              </div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      handle: _propTypes.default.string,
      /**
       * `cancel` specifies a selector to be used to prevent drag initialization.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *           return(
       *               <Draggable cancel=".cancel">
       *                   <div>
       *                     <div className="cancel">You can't drag from here</div>
       *                     <div>Dragging here works fine</div>
       *                   </div>
       *               </Draggable>
       *           );
       *       }
       *   });
       * ```
       */
      cancel: _propTypes.default.string,
      /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
       * Unfortunately, in order for <Draggable> to work properly, we need raw access
       * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
       * as in this example:
       *
       * function MyComponent() {
       *   const nodeRef = React.useRef(null);
       *   return (
       *     <Draggable nodeRef={nodeRef}>
       *       <div ref={nodeRef}>Example Target</div>
       *     </Draggable>
       *   );
       * }
       *
       * This can be used for arbitrarily nested components, so long as the ref ends up
       * pointing to the actual child DOM node and not a custom component.
       */
      nodeRef: _propTypes.default.object,
      /**
       * Called when dragging starts.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onStart: _propTypes.default.func,
      /**
       * Called while dragging.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onDrag: _propTypes.default.func,
      /**
       * Called when dragging stops.
       * If this function returns the boolean false, the drag will remain active.
       */
      onStop: _propTypes.default.func,
      /**
       * A workaround option which can be passed if onMouseDown needs to be accessed,
       * since it'll always be blocked (as there is internal use of onMouseDown)
       */
      onMouseDown: _propTypes.default.func,
      /**
       * `scale`, if set, applies scaling while dragging an element
       */
      scale: _propTypes.default.number,
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(DraggableCore2, "defaultProps", {
      allowAnyClick: false,
      // by default only accept left click
      disabled: false,
      enableUserSelectHack: true,
      onStart: function() {
      },
      onDrag: function() {
      },
      onStop: function() {
      },
      onMouseDown: function() {
      },
      scale: 1
    });
  }
});

// node_modules/react-draggable/build/cjs/Draggable.js
var require_Draggable = __commonJS({
  "node_modules/react-draggable/build/cjs/Draggable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DraggableCore", {
      enumerable: true,
      get: function() {
        return _DraggableCore.default;
      }
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _DraggableCore = _interopRequireDefault(require_DraggableCore());
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var Draggable = class extends React2.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(_ref, _ref2) {
        let {
          position
        } = _ref;
        let {
          prevPropsPosition
        } = _ref2;
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
          (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
            position,
            prevPropsPosition
          });
          return {
            x: position.x,
            y: position.y,
            prevPropsPosition: {
              ...position
            }
          };
        }
        return null;
      }
      constructor(props) {
        super(props);
        _defineProperty(this, "onDragStart", (e2, coreData) => {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          const shouldStart = this.props.onStart(e2, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldStart === false) return false;
          this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty(this, "onDrag", (e2, coreData) => {
          if (!this.state.dragging) return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          const uiData = (0, _positionFns.createDraggableData)(this, coreData);
          const newState = {
            x: uiData.x,
            y: uiData.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x,
              y
            } = newState;
            newState.x += this.state.slackX;
            newState.y += this.state.slackY;
            const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = this.state.slackX + (x - newState.x);
            newState.slackY = this.state.slackY + (y - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - this.state.x;
            uiData.deltaY = newState.y - this.state.y;
          }
          const shouldUpdate = this.props.onDrag(e2, uiData);
          if (shouldUpdate === false) return false;
          this.setState(newState);
        });
        _defineProperty(this, "onDragStop", (e2, coreData) => {
          if (!this.state.dragging) return false;
          const shouldContinue = this.props.onStop(e2, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldContinue === false) return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          const newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          const controlled = Boolean(this.props.position);
          if (controlled) {
            const {
              x,
              y
            } = this.props.position;
            newState.x = x;
            newState.y = y;
          }
          this.setState(newState);
        });
        this.state = {
          // Whether or not we are currently dragging.
          dragging: false,
          // Whether or not we have been dragged before.
          dragged: false,
          // Current transform x and y.
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: {
            ...props.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
      }
      componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
      componentWillUnmount() {
        this.setState({
          dragging: false
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props$nodeRef$c, _this$props;
        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
      }
      render() {
        const {
          axis,
          bounds,
          children,
          defaultPosition,
          defaultClassName,
          defaultClassNameDragging,
          defaultClassNameDragged,
          position,
          positionOffset,
          scale,
          ...draggableCoreProps
        } = this.props;
        let style2 = {};
        let svgTransform = null;
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
          // Set left if horizontal drag is enabled
          x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
          // Set top if vertical drag is enabled
          y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style2 = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        }
        const className = (0, _clsx.default)(children.props.className || "", defaultClassName, {
          [defaultClassNameDragging]: this.state.dragging,
          [defaultClassNameDragged]: this.state.dragged
        });
        return React2.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), React2.cloneElement(React2.Children.only(children), {
          className,
          style: {
            ...children.props.style,
            ...style2
          },
          transform: svgTransform
        }));
      }
    };
    exports.default = Draggable;
    _defineProperty(Draggable, "displayName", "Draggable");
    _defineProperty(Draggable, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ..._DraggableCore.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(Draggable, "defaultProps", {
      ..._DraggableCore.default.defaultProps,
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  }
});

// node_modules/react-draggable/build/cjs/cjs.js
var require_cjs = __commonJS({
  "node_modules/react-draggable/build/cjs/cjs.js"(exports, module) {
    "use strict";
    var {
      default: Draggable,
      DraggableCore: DraggableCore2
    } = require_Draggable();
    module.exports = Draggable;
    module.exports.default = Draggable;
    module.exports.DraggableCore = DraggableCore2;
  }
});

// node_modules/cnbuilder/esm/cnb.js
var isArray = Array.isArray;
var toClassName = function(val) {
  var str = "";
  if (typeof val === "string")
    str += val;
  else if (typeof val === "object") {
    var tmp = void 0;
    if (isArray(val)) {
      var i2 = 0;
      var l = val.length;
      while (i2 < l) {
        tmp = toClassName(val[i2++]);
        if (tmp) {
          if (str) {
            str += " ";
          }
          str += tmp;
        }
      }
    } else {
      for (tmp in val) {
        if (tmp && val[tmp]) {
          if (str) {
            str += " ";
          }
          str += tmp;
        }
      }
    }
  }
  return str;
};
function cnb() {
  var l = arguments.length;
  var i2 = 0;
  var n;
  var tmp;
  var str = "";
  while (i2 < l) {
    n = arguments[i2++];
    if (n) {
      tmp = toClassName(n);
      if (tmp) {
        if (str) {
          str += " ";
        }
        str += tmp;
      }
    }
  }
  return str;
}

// node_modules/cnbuilder/esm/dcnb.js
var create = Object.create;
var isArray2 = Array.isArray;
function Storage() {
}
Storage.prototype = create(null);

// node_modules/react-scrollbars-custom/dist/rsc.esm.js
var React = __toESM(require_react());

// node_modules/zoom-level/dist/zoom-level.esm.js
function e(e2, i2, t, o) {
  for (; i2 >= t && !e2("(min-resolution: " + i2 / o + "dppx)").matches; ) i2--;
  return i2;
}
function i(i2) {
  if (void 0 === i2 && (i2 = window), !i2) return 1;
  if (void 0 !== i2.devicePixelRatio) return i2.devicePixelRatio;
  var t = i2.document.frames;
  return void 0 !== t ? void 0 !== t.devicePixelRatio ? t.devicePixelRatio : t.screen.deviceXDPI / t.screen.systemXDPI : void 0 !== i2.matchMedia ? function(i3) {
    for (var t2 = i3.matchMedia, o = 10, n = 0.1, r2 = 1, a = o, c = 0; c < 4; c++) o = (a = 10 * e(t2, o, n, r2)) + 9, n = a, r2 *= 10;
    return a / r2;
  }(i2) : 1;
}

// node_modules/react-scrollbars-custom/dist/rsc.esm.js
var import_react_draggable = __toESM(require_cjs());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t[p[i2]] = s[p[i2]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var doc = (typeof document === "undefined" ? "undefined" : _typeof(document)) === "object" ? document : null;
var isBrowser = typeof window !== "undefined" && typeof navigator !== "undefined" && typeof document !== "undefined";
var isUndef = function isUndef2(v) {
  return typeof v === "undefined";
};
var isFun = function isFun2(v) {
  return typeof v === "function";
};
var isNum = function isNum2(v) {
  return typeof v === "number";
};
var renderDivWithRenderer = function renderDivWithRenderer2(props, elementRef) {
  if (isFun(props.renderer)) {
    props.elementRef = elementRef;
    var renderer = props.renderer;
    delete props.renderer;
    return renderer(props);
  }
  delete props.elementRef;
  return React.createElement("div", __assign({}, props, {
    ref: elementRef
  }));
};
var getInnerSize = function getInnerSize2(el, dimension, padding1, padding2) {
  var styles = getComputedStyle(el);
  if (styles.boxSizing === "border-box") {
    return Math.max(0, (Number.parseFloat(styles[dimension]) || 0) - (Number.parseFloat(styles[padding1]) || 0) - (Number.parseFloat(styles[padding2]) || 0));
  }
  return Number.parseFloat(styles[dimension]) || 0;
};
var getInnerHeight = function getInnerHeight2(el) {
  return getInnerSize(el, "height", "paddingTop", "paddingBottom");
};
var getInnerWidth = function getInnerWidth2(el) {
  return getInnerSize(el, "width", "paddingLeft", "paddingRight");
};
var uuid = function uuid2() {
  var uuid3 = "";
  for (var i2 = 0; i2 < 32; i2++) {
    switch (i2) {
      case 8:
      case 20: {
        uuid3 += "-".concat(Math.trunc(Math.random() * 16).toString(16));
        break;
      }
      case 12: {
        uuid3 += "-4";
        break;
      }
      case 16: {
        uuid3 += "-".concat((Math.random() * 16 | 0 & 3 | 8).toString(16));
        break;
      }
      default: {
        uuid3 += Math.trunc(Math.random() * 16).toString(16);
      }
    }
  }
  return uuid3;
};
var calcThumbSize = function calcThumbSize2(contentSize, viewportSize, trackSize, minimalSize, maximalSize) {
  if (viewportSize >= contentSize) {
    return 0;
  }
  var thumbSize = viewportSize / contentSize * trackSize;
  if (isNum(maximalSize)) {
    thumbSize = Math.min(maximalSize, thumbSize);
  }
  if (isNum(minimalSize)) {
    thumbSize = Math.max(minimalSize, thumbSize);
  }
  return thumbSize;
};
var calcThumbOffset = function calcThumbOffset2(contentSize, viewportSize, trackSize, thumbSize, scroll) {
  if (!scroll || !thumbSize || viewportSize >= contentSize) {
    return 0;
  }
  return (trackSize - thumbSize) * scroll / (contentSize - viewportSize);
};
var calcScrollForThumbOffset = function calcScrollForThumbOffset2(contentSize, viewportSize, trackSize, thumbSize, thumbOffset) {
  if (!thumbOffset || !thumbSize || viewportSize >= contentSize) {
    return 0;
  }
  return thumbOffset * (contentSize - viewportSize) / (trackSize - thumbSize);
};
var getScrollbarWidth = function getScrollbarWidth2(force) {
  if (force === void 0) {
    force = false;
  }
  if (!doc) {
    getScrollbarWidth2._cache = 0;
    return getScrollbarWidth2._cache;
  }
  if (!force && !isUndef(getScrollbarWidth2._cache)) {
    return getScrollbarWidth2._cache;
  }
  var el = doc.createElement("div");
  el.setAttribute("style", "position:absolute;width:100px;height:100px;top:-999px;left:-999px;overflow:scroll;");
  doc.body.append(el);
  if (el.clientWidth === 0) {
    el.remove();
    return;
  }
  getScrollbarWidth2._cache = 100 - el.clientWidth;
  el.remove();
  return getScrollbarWidth2._cache;
};
var shouldReverseRtlScroll = function shouldReverseRtlScroll2(force) {
  if (force === void 0) {
    force = false;
  }
  if (!force && !isUndef(shouldReverseRtlScroll2._cache)) {
    return shouldReverseRtlScroll2._cache;
  }
  if (!doc) {
    shouldReverseRtlScroll2._cache = false;
    return shouldReverseRtlScroll2._cache;
  }
  var el = doc.createElement("div");
  var child = doc.createElement("div");
  el.append(child);
  el.setAttribute("style", "position:absolute;width:100px;height:100px;top:-999px;left:-999px;overflow:scroll;direction:rtl");
  child.setAttribute("style", "width:1000px;height:1000px");
  doc.body.append(el);
  el.scrollLeft = -50;
  shouldReverseRtlScroll2._cache = el.scrollLeft === -50;
  el.remove();
  return shouldReverseRtlScroll2._cache;
};
var Emittr = (
  /** @class */
  function() {
    function Emittr2(maxHandlers) {
      if (maxHandlers === void 0) {
        maxHandlers = 10;
      }
      this.setMaxHandlers(maxHandlers);
      this._handlers = /* @__PURE__ */ Object.create(null);
    }
    Emittr2._callEventHandlers = function(emitter, handlers, args) {
      if (!handlers.length) {
        return;
      }
      if (handlers.length === 1) {
        Reflect.apply(handlers[0], emitter, args);
        return;
      }
      handlers = __spreadArray([], handlers, true);
      var idx;
      for (idx = 0; idx < handlers.length; idx++) {
        Reflect.apply(handlers[idx], emitter, args);
      }
    };
    Emittr2.prototype.setMaxHandlers = function(count) {
      if (!isNum(count) || count <= 0) {
        throw new TypeError("Expected maxHandlers to be a positive number, got '".concat(count, "' of type ").concat(_typeof(count)));
      }
      this._maxHandlers = count;
      return this;
    };
    Emittr2.prototype.getMaxHandlers = function() {
      return this._maxHandlers;
    };
    Emittr2.prototype.emit = function(name) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (_typeof(this._handlers[name]) !== "object" || !Array.isArray(this._handlers[name])) {
        return false;
      }
      Emittr2._callEventHandlers(this, this._handlers[name], args);
      return true;
    };
    Emittr2.prototype.on = function(name, handler) {
      Emittr2._addHandler(this, name, handler);
      return this;
    };
    Emittr2.prototype.prependOn = function(name, handler) {
      Emittr2._addHandler(this, name, handler, true);
      return this;
    };
    Emittr2.prototype.once = function(name, handler) {
      if (!isFun(handler)) {
        throw new TypeError("Expected event handler to be a function, got ".concat(_typeof(handler)));
      }
      Emittr2._addHandler(this, name, this._wrapOnceHandler(name, handler));
      return this;
    };
    Emittr2.prototype.prependOnce = function(name, handler) {
      if (!isFun(handler)) {
        throw new TypeError("Expected event handler to be a function, got ".concat(_typeof(handler)));
      }
      Emittr2._addHandler(this, name, this._wrapOnceHandler(name, handler), true);
      return this;
    };
    Emittr2.prototype.off = function(name, handler) {
      Emittr2._removeHandler(this, name, handler);
      return this;
    };
    Emittr2.prototype.removeAllHandlers = function() {
      var handlers = this._handlers;
      this._handlers = /* @__PURE__ */ Object.create(null);
      var removeHandlers = handlers.removeHandler;
      delete handlers.removeHandler;
      var idx;
      var eventName;
      for (eventName in handlers) {
        for (idx = handlers[eventName].length - 1; idx >= 0; idx--) {
          Emittr2._callEventHandlers(this, removeHandlers, [eventName, handlers[eventName][idx].handler || handlers[eventName][idx]]);
        }
      }
      return this;
    };
    Emittr2.prototype._wrapOnceHandler = function(name, handler) {
      var onceState = {
        fired: false,
        handler,
        wrappedHandler: void 0,
        emitter: this,
        event: name
      };
      var wrappedHandler = Emittr2._onceWrapper.bind(onceState);
      onceState.wrappedHandler = wrappedHandler;
      wrappedHandler.handler = handler;
      wrappedHandler.event = name;
      return wrappedHandler;
    };
    Emittr2._addHandler = function(emitter, name, handler, prepend) {
      if (prepend === void 0) {
        prepend = false;
      }
      if (!isFun(handler)) {
        throw new TypeError("Expected event handler to be a function, got ".concat(_typeof(handler)));
      }
      emitter._handlers[name] = emitter._handlers[name] || [];
      emitter.emit("addHandler", name, handler);
      if (prepend) {
        emitter._handlers[name].unshift(handler);
      } else {
        emitter._handlers[name].push(handler);
      }
      return emitter;
    };
    Emittr2._onceWrapper = function _onceWrapper() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.fired) {
        this.fired = true;
        this.emitter.off(this.event, this.wrappedHandler);
        Reflect.apply(this.handler, this.emitter, args);
      }
    };
    Emittr2._removeHandler = function(emitter, name, handler) {
      if (!isFun(handler)) {
        throw new TypeError("Expected event handler to be a function, got ".concat(_typeof(handler)));
      }
      if (isUndef(emitter._handlers[name]) || !emitter._handlers[name].length) {
        return emitter;
      }
      var idx = -1;
      if (emitter._handlers[name].length === 1) {
        if (emitter._handlers[name][0] === handler || emitter._handlers[name][0].handler === handler) {
          idx = 0;
          handler = emitter._handlers[name][0].handler || emitter._handlers[name][0];
        }
      } else {
        for (idx = emitter._handlers[name].length - 1; idx >= 0; idx--) {
          if (emitter._handlers[name][idx] === handler || emitter._handlers[name][idx].handler === handler) {
            handler = emitter._handlers[name][idx].handler || emitter._handlers[name][idx];
            break;
          }
        }
      }
      if (idx === -1) {
        return emitter;
      }
      if (idx === 0) {
        emitter._handlers[name].shift();
      } else {
        emitter._handlers[name].splice(idx, 1);
      }
      emitter.emit("removeHandler", name, handler);
      return emitter;
    };
    return Emittr2;
  }()
);
var RAFLoop = (
  /** @class */
  function() {
    function RAFLoop2() {
      var _this = this;
      this.targets = [];
      this.animationFrameID = 0;
      this._isActive = false;
      this.start = function() {
        if (!_this._isActive && _this.targets.length) {
          _this._isActive = true;
          if (_this.animationFrameID) cancelAnimationFrame(_this.animationFrameID);
          _this.animationFrameID = requestAnimationFrame(_this.rafCallback);
        }
        return _this;
      };
      this.stop = function() {
        if (_this._isActive) {
          _this._isActive = false;
          if (_this.animationFrameID) cancelAnimationFrame(_this.animationFrameID);
          _this.animationFrameID = 0;
        }
        return _this;
      };
      this.addTarget = function(target, silent) {
        if (silent === void 0) {
          silent = false;
        }
        if (!_this.targets.includes(target)) {
          _this.targets.push(target);
          if (_this.targets.length === 1 && !silent) _this.start();
        }
        return _this;
      };
      this.removeTarget = function(target) {
        var idx = _this.targets.indexOf(target);
        if (idx !== -1) {
          _this.targets.splice(idx, 1);
          if (_this.targets.length === 0) _this.stop();
        }
        return _this;
      };
      this.rafCallback = function() {
        if (!_this._isActive) {
          return 0;
        }
        for (var i2 = 0; i2 < _this.targets.length; i2++) {
          if (!_this.targets[i2]._unmounted) _this.targets[i2].update();
        }
        _this.animationFrameID = requestAnimationFrame(_this.rafCallback);
        return _this.animationFrameID;
      };
    }
    Object.defineProperty(RAFLoop2.prototype, "isActive", {
      /**
       * @description Loop's state.
       */
      get: function get() {
        return this._isActive;
      },
      enumerable: false,
      configurable: true
    });
    return RAFLoop2;
  }()
);
var Loop = new RAFLoop();
var AXIS_DIRECTION;
(function(AXIS_DIRECTION2) {
  AXIS_DIRECTION2["X"] = "x";
  AXIS_DIRECTION2["Y"] = "y";
})(AXIS_DIRECTION || (AXIS_DIRECTION = {}));
var TRACK_CLICK_BEHAVIOR;
(function(TRACK_CLICK_BEHAVIOR2) {
  TRACK_CLICK_BEHAVIOR2["JUMP"] = "jump";
  TRACK_CLICK_BEHAVIOR2["STEP"] = "step";
})(TRACK_CLICK_BEHAVIOR || (TRACK_CLICK_BEHAVIOR = {}));
var ScrollbarThumb = (
  /** @class */
  function(_super) {
    __extends(ScrollbarThumb2, _super);
    function ScrollbarThumb2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.element = null;
      _this.initialOffsetX = 0;
      _this.initialOffsetY = 0;
      _this.elementRefHack = React.createRef();
      _this.lastDragData = {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0,
        lastX: 0,
        lastY: 0
      };
      _this.handleOnDragStart = function(ev, data) {
        if (!_this.element) {
          _this.handleOnDragStop(ev, data);
          return;
        }
        if (isBrowser) {
          _this.prevUserSelect = document.body.style.userSelect;
          document.body.style.userSelect = "none";
          _this.prevOnSelectStart = document.onselectstart;
          document.addEventListener("selectstart", ScrollbarThumb2.selectStartReplacer);
        }
        if (_this.props.onDragStart) {
          _this.props.onDragStart(_this.lastDragData = {
            x: data.x - _this.initialOffsetX,
            y: data.y - _this.initialOffsetY,
            lastX: data.lastX - _this.initialOffsetX,
            lastY: data.lastY - _this.initialOffsetY,
            deltaX: data.deltaX,
            deltaY: data.deltaY
          });
        }
        _this.element.classList.add("dragging");
      };
      _this.handleOnDrag = function(ev, data) {
        if (!_this.element) {
          _this.handleOnDragStop(ev, data);
          return;
        }
        if (_this.props.onDrag) {
          _this.props.onDrag(_this.lastDragData = {
            x: data.x - _this.initialOffsetX,
            y: data.y - _this.initialOffsetY,
            lastX: data.lastX - _this.initialOffsetX,
            lastY: data.lastY - _this.initialOffsetY,
            deltaX: data.deltaX,
            deltaY: data.deltaY
          });
        }
      };
      _this.handleOnDragStop = function(ev, data) {
        var resultData = data ? {
          x: data.x - _this.initialOffsetX,
          y: data.y - _this.initialOffsetY,
          lastX: data.lastX - _this.initialOffsetX,
          lastY: data.lastY - _this.initialOffsetY,
          deltaX: data.deltaX,
          deltaY: data.deltaY
        } : _this.lastDragData;
        if (_this.props.onDragEnd) _this.props.onDragEnd(resultData);
        if (_this.element) _this.element.classList.remove("dragging");
        if (isBrowser) {
          document.body.style.userSelect = _this.prevUserSelect;
          if (_this.prevOnSelectStart) {
            document.addEventListener("selectstart", _this.prevOnSelectStart);
          }
          _this.prevOnSelectStart = null;
        }
        _this.initialOffsetX = 0;
        _this.initialOffsetY = 0;
        _this.lastDragData = {
          x: 0,
          y: 0,
          deltaX: 0,
          deltaY: 0,
          lastX: 0,
          lastY: 0
        };
      };
      _this.handleOnMouseDown = function(ev) {
        if (!_this.element) {
          return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        if (!isUndef(ev.offsetX)) {
          _this.initialOffsetX = ev.offsetX;
          _this.initialOffsetY = ev.offsetY;
        } else {
          var rect = _this.element.getBoundingClientRect();
          _this.initialOffsetX = (ev.clientX || ev.touches[0].clientX) - rect.left;
          _this.initialOffsetY = (ev.clientY || ev.touches[0].clientY) - rect.top;
        }
      };
      _this.elementRef = function(ref) {
        if (isFun(_this.props.elementRef)) _this.props.elementRef(ref);
        _this.element = ref;
        _this.elementRefHack.current = ref;
      };
      return _this;
    }
    ScrollbarThumb2.prototype.componentDidMount = function() {
      if (!this.element) {
        this.setState(function() {
          throw new Error("<ScrollbarThumb> Element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
        });
      }
    };
    ScrollbarThumb2.prototype.componentWillUnmount = function() {
      this.handleOnDragStop();
      this.elementRef(null);
    };
    ScrollbarThumb2.prototype.render = function() {
      var _a = this.props;
      _a.elementRef;
      var axis = _a.axis;
      _a.onDrag;
      _a.onDragEnd;
      _a.onDragStart;
      var props = __rest(_a, ["elementRef", "axis", "onDrag", "onDragEnd", "onDragStart"]);
      props.className = cnb("ScrollbarsCustom-Thumb", axis === AXIS_DIRECTION.X ? "ScrollbarsCustom-ThumbX" : "ScrollbarsCustom-ThumbY", props.className);
      if (props.renderer) {
        props.axis = axis;
      }
      return React.createElement(import_react_draggable.DraggableCore, {
        allowAnyClick: false,
        enableUserSelectHack: false,
        onMouseDown: this.handleOnMouseDown,
        onDrag: this.handleOnDrag,
        onStart: this.handleOnDragStart,
        onStop: this.handleOnDragStop,
        nodeRef: this.elementRefHack
      }, renderDivWithRenderer(props, this.elementRef));
    };
    ScrollbarThumb2.selectStartReplacer = function() {
      return false;
    };
    return ScrollbarThumb2;
  }(React.Component)
);
var ScrollbarTrack = (
  /** @class */
  function(_super) {
    __extends(ScrollbarTrack2, _super);
    function ScrollbarTrack2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.element = null;
      _this.elementRef = function(ref) {
        if (isFun(_this.props.elementRef)) _this.props.elementRef(ref);
        _this.element = ref;
      };
      _this.handleClick = function(ev) {
        if (!ev || !_this.element || ev.button !== 0) {
          return;
        }
        if (isFun(_this.props.onClick) && ev.target === _this.element) {
          if (!isUndef(ev.offsetX)) {
            _this.props.onClick(ev, {
              axis: _this.props.axis,
              offset: _this.props.axis === AXIS_DIRECTION.X ? ev.offsetX : ev.offsetY
            });
          } else {
            var rect = _this.element.getBoundingClientRect();
            _this.props.onClick(ev, {
              axis: _this.props.axis,
              offset: _this.props.axis === AXIS_DIRECTION.X ? (ev.clientX || ev.touches[0].clientX) - rect.left : (ev.clientY || ev.touches[0].clientY) - rect.top
            });
          }
        }
        return true;
      };
      return _this;
    }
    ScrollbarTrack2.prototype.componentDidMount = function() {
      if (!this.element) {
        this.setState(function() {
          throw new Error("Element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
        });
        return;
      }
      this.element.addEventListener("click", this.handleClick);
    };
    ScrollbarTrack2.prototype.componentWillUnmount = function() {
      if (this.element) {
        this.element.removeEventListener("click", this.handleClick);
        this.element = null;
        this.elementRef(null);
      }
    };
    ScrollbarTrack2.prototype.render = function() {
      var _a = this.props;
      _a.elementRef;
      var axis = _a.axis;
      _a.onClick;
      var props = __rest(_a, ["elementRef", "axis", "onClick"]);
      props.className = cnb("ScrollbarsCustom-Track", axis === AXIS_DIRECTION.X ? "ScrollbarsCustom-TrackX" : "ScrollbarsCustom-TrackY", props.className);
      if (props.renderer) {
        props.axis = axis;
      }
      return renderDivWithRenderer(props, this.elementRef);
    };
    return ScrollbarTrack2;
  }(React.Component)
);
var style = {
  holder: {
    position: "relative",
    width: "100%",
    height: "100%"
  },
  wrapper: {
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  },
  content: {
    boxSizing: "border-box"
  },
  track: {
    common: {
      position: "absolute",
      overflow: "hidden",
      borderRadius: 4,
      background: "rgba(0,0,0,.1)",
      userSelect: "none"
    },
    x: {
      height: 10,
      width: "calc(100% - 20px)",
      bottom: 0,
      left: 10
    },
    y: {
      width: 10,
      height: "calc(100% - 20px)",
      top: 10
    }
  },
  thumb: {
    common: {
      cursor: "pointer",
      borderRadius: 4,
      background: "rgba(0,0,0,.4)"
    },
    x: {
      height: "100%",
      width: 0
    },
    y: {
      width: "100%",
      height: 0
    }
  }
};
var pageZoomLevel = isBrowser ? i() : 1;
if (isBrowser) {
  window.addEventListener("resize", function() {
    pageZoomLevel = i();
  }, {
    passive: true
  });
}
var ScrollbarContext = React.createContext({
  parentScrollbar: null
});
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar2, _super);
    function Scrollbar2(props) {
      var _this = _super.call(this, props) || this;
      _this.getScrollState = function(force) {
        if (force === void 0) {
          force = false;
        }
        if (_this.scrollValues && !force) {
          return __assign({}, _this.scrollValues);
        }
        var scrollState = {
          clientHeight: 0,
          clientWidth: 0,
          contentScrollHeight: 0,
          contentScrollWidth: 0,
          scrollHeight: 0,
          scrollWidth: 0,
          scrollTop: 0,
          scrollLeft: 0,
          scrollYBlocked: false,
          scrollXBlocked: false,
          scrollYPossible: false,
          scrollXPossible: false,
          trackYVisible: false,
          trackXVisible: false,
          zoomLevel: pageZoomLevel * 1,
          isRTL: void 0
        };
        var props2 = _this.props;
        scrollState.isRTL = _this.state.isRTL;
        scrollState.scrollYBlocked = props2.noScroll || props2.noScrollY;
        scrollState.scrollXBlocked = props2.noScroll || props2.noScrollX;
        if (_this.scrollerElement) {
          scrollState.clientHeight = _this.scrollerElement.clientHeight;
          scrollState.clientWidth = _this.scrollerElement.clientWidth;
          scrollState.scrollHeight = _this.scrollerElement.scrollHeight;
          scrollState.scrollWidth = _this.scrollerElement.scrollWidth;
          scrollState.scrollTop = _this.scrollerElement.scrollTop;
          scrollState.scrollLeft = _this.scrollerElement.scrollLeft;
          scrollState.scrollYPossible = !scrollState.scrollYBlocked && scrollState.scrollHeight > scrollState.clientHeight;
          scrollState.scrollXPossible = !scrollState.scrollXBlocked && scrollState.scrollWidth > scrollState.clientWidth;
          scrollState.trackYVisible = scrollState.scrollYPossible || props2.permanentTracks || props2.permanentTrackY;
          scrollState.trackXVisible = scrollState.scrollXPossible || props2.permanentTracks || props2.permanentTrackX;
        }
        if (_this.contentElement) {
          scrollState.contentScrollHeight = _this.contentElement.scrollHeight;
          scrollState.contentScrollWidth = _this.contentElement.scrollWidth;
        }
        return scrollState;
      };
      _this.scrollToTop = function() {
        if (_this.scrollerElement) {
          _this.scrollerElement.scrollTop = 0;
        }
        return _this;
      };
      _this.scrollToLeft = function() {
        if (_this.scrollerElement) {
          _this.scrollerElement.scrollLeft = 0;
        }
        return _this;
      };
      _this.scrollToBottom = function() {
        if (_this.scrollerElement) {
          _this.scrollerElement.scrollTop = _this.scrollerElement.scrollHeight - _this.scrollerElement.clientHeight;
        }
        return _this;
      };
      _this.scrollToRight = function() {
        if (_this.scrollerElement) {
          _this.scrollerElement.scrollLeft = _this.scrollerElement.scrollWidth - _this.scrollerElement.clientWidth;
        }
        return _this;
      };
      _this.scrollTo = function(x, y) {
        if (_this.scrollerElement) {
          if (isNum(x)) _this.scrollerElement.scrollLeft = x;
          if (isNum(y)) _this.scrollerElement.scrollTop = y;
        }
        return _this;
      };
      _this.centerAt = function(x, y) {
        if (_this.scrollerElement) {
          if (isNum(x)) _this.scrollerElement.scrollLeft = x - _this.scrollerElement.clientWidth / 2;
          if (isNum(y)) _this.scrollerElement.scrollTop = y - _this.scrollerElement.clientHeight / 2;
        }
        return _this;
      };
      _this.update = function(force) {
        if (force === void 0) {
          force = false;
        }
        if (!_this.scrollerElement) {
          return;
        }
        if (isUndef(_this.state.isRTL)) {
          _this.setState({
            isRTL: getComputedStyle(_this.scrollerElement).direction === "rtl"
          });
          return _this.getScrollState();
        }
        var scrollState = _this.getScrollState(true);
        var prevScrollState = __assign({}, _this.scrollValues);
        var props2 = _this.props;
        var bitmask = 0;
        if (!force) {
          if (prevScrollState.clientHeight !== scrollState.clientHeight) bitmask |= Math.trunc(1);
          if (prevScrollState.clientWidth !== scrollState.clientWidth) bitmask |= 1 << 1;
          if (prevScrollState.scrollHeight !== scrollState.scrollHeight) bitmask |= 1 << 2;
          if (prevScrollState.scrollWidth !== scrollState.scrollWidth) bitmask |= 1 << 3;
          if (prevScrollState.scrollTop !== scrollState.scrollTop) bitmask |= 1 << 4;
          if (prevScrollState.scrollLeft !== scrollState.scrollLeft) bitmask |= 1 << 5;
          if (prevScrollState.scrollYBlocked !== scrollState.scrollYBlocked) bitmask |= 1 << 6;
          if (prevScrollState.scrollXBlocked !== scrollState.scrollXBlocked) bitmask |= 1 << 7;
          if (prevScrollState.scrollYPossible !== scrollState.scrollYPossible) bitmask |= 1 << 8;
          if (prevScrollState.scrollXPossible !== scrollState.scrollXPossible) bitmask |= 1 << 9;
          if (prevScrollState.trackYVisible !== scrollState.trackYVisible) bitmask |= 1 << 10;
          if (prevScrollState.trackXVisible !== scrollState.trackXVisible) bitmask |= 1 << 11;
          if (prevScrollState.isRTL !== scrollState.isRTL) bitmask |= 1 << 12;
          if (prevScrollState.contentScrollHeight !== scrollState.contentScrollHeight) bitmask |= 1 << 13;
          if (prevScrollState.contentScrollWidth !== scrollState.contentScrollWidth) bitmask |= 1 << 14;
          if (prevScrollState.zoomLevel !== scrollState.zoomLevel) bitmask |= 1 << 15;
          if (bitmask === 0) {
            return prevScrollState;
          }
        } else {
          bitmask = 32767;
        }
        if (!props2.native && _this.holderElement) {
          if (bitmask & 1 << 13 && (props2.translateContentSizesToHolder || props2.translateContentSizeYToHolder)) {
            _this.holderElement.style.height = "".concat(scrollState.contentScrollHeight, "px");
          }
          if (bitmask & 1 << 14 && (props2.translateContentSizesToHolder || props2.translateContentSizeXToHolder)) {
            _this.holderElement.style.width = "".concat(scrollState.contentScrollWidth, "px");
          }
          if (props2.translateContentSizesToHolder || props2.translateContentSizeYToHolder || props2.translateContentSizeXToHolder) {
            if (!scrollState.clientHeight && scrollState.contentScrollHeight || !scrollState.clientWidth && scrollState.contentScrollWidth) {
              return;
            }
          }
        }
        if (bitmask & 1 << 10 || bitmask & 1 << 11) {
          prevScrollState.scrollYBlocked = scrollState.scrollYBlocked;
          prevScrollState.scrollXBlocked = scrollState.scrollXBlocked;
          prevScrollState.scrollYPossible = scrollState.scrollYPossible;
          prevScrollState.scrollXPossible = scrollState.scrollXPossible;
          if (_this.trackYElement && bitmask & 1 << 10) {
            _this.trackYElement.style.display = scrollState.trackYVisible ? "" : "none";
          }
          if (_this.trackXElement && bitmask & 1 << 11) {
            _this.trackXElement.style.display = scrollState.trackXVisible ? "" : "none";
          }
          _this.scrollValues = prevScrollState;
          _this.setState({
            trackYVisible: _this.scrollValues.trackYVisible = scrollState.trackYVisible,
            trackXVisible: _this.scrollValues.trackXVisible = scrollState.trackXVisible
          });
          return;
        }
        (props2.native ? _this.updaterNative : _this.updaterCustom)(bitmask, scrollState);
        _this.scrollValues = scrollState;
        if (!props2.native && bitmask & 1 << 15) {
          getScrollbarWidth(true);
          _this.forceUpdate();
        }
        _this.eventEmitter.emit("update", __assign({}, scrollState), prevScrollState);
        if (bitmask & 1 << 4 || bitmask & 1 << 5) _this.eventEmitter.emit("scroll", __assign({}, scrollState), prevScrollState);
        return _this.scrollValues;
      };
      _this.updaterNative = function() {
        return true;
      };
      _this.updaterCustom = function(bitmask, scrollValues) {
        var props2 = _this.props;
        if (_this.trackYElement) {
          if (_this.thumbYElement && (bitmask & Math.trunc(1) || bitmask & 1 << 2 || bitmask & 1 << 4 || bitmask & 1 << 6 || bitmask & 1 << 8)) {
            if (scrollValues.scrollYPossible) {
              var trackInnerSize = getInnerHeight(_this.trackYElement);
              var thumbSize = calcThumbSize(scrollValues.scrollHeight, scrollValues.clientHeight, trackInnerSize, props2.minimalThumbYSize || props2.minimalThumbSize, props2.maximalThumbYSize || props2.maximalThumbSize);
              var thumbOffset = calcThumbOffset(scrollValues.scrollHeight, scrollValues.clientHeight, trackInnerSize, thumbSize, scrollValues.scrollTop);
              _this.thumbYElement.style.transform = "translateY(".concat(thumbOffset, "px)");
              _this.thumbYElement.style.height = "".concat(thumbSize, "px");
              _this.thumbYElement.style.display = "";
            } else {
              _this.thumbYElement.style.transform = "";
              _this.thumbYElement.style.height = "0px";
              _this.thumbYElement.style.display = "none";
            }
          }
        }
        if (_this.trackXElement) {
          if (_this.thumbXElement && (bitmask & 1 << 1 || bitmask & 1 << 3 || bitmask & 1 << 5 || bitmask & 1 << 7 || bitmask & 1 << 9 || bitmask & 1 << 12)) {
            if (scrollValues.scrollXPossible) {
              var trackInnerSize = getInnerWidth(_this.trackXElement);
              var thumbSize = calcThumbSize(scrollValues.scrollWidth, scrollValues.clientWidth, trackInnerSize, props2.minimalThumbXSize || props2.minimalThumbSize, props2.maximalThumbXSize || props2.maximalThumbSize);
              var thumbOffset = calcThumbOffset(scrollValues.scrollWidth, scrollValues.clientWidth, trackInnerSize, thumbSize, scrollValues.scrollLeft);
              if (_this.state.isRTL && shouldReverseRtlScroll()) {
                thumbOffset += trackInnerSize - thumbSize;
              }
              _this.thumbXElement.style.transform = "translateX(".concat(thumbOffset, "px)");
              _this.thumbXElement.style.width = "".concat(thumbSize, "px");
              _this.thumbXElement.style.display = "";
            } else {
              _this.thumbXElement.style.transform = "";
              _this.thumbXElement.style.width = "0px";
              _this.thumbXElement.style.display = "none";
            }
          }
        }
        return true;
      };
      _this.elementRefHolder = function(ref) {
        _this.holderElement = ref;
        if (isFun(_this.props.elementRef)) {
          _this.props.elementRef(ref);
        }
      };
      _this.elementRefWrapper = function(ref) {
        _this.wrapperElement = ref;
        if (isFun(_this.props.wrapperProps.elementRef)) {
          _this.props.wrapperProps.elementRef(ref);
        }
      };
      _this.elementRefScroller = function(ref) {
        _this.scrollerElement = ref;
        if (isFun(_this.props.scrollerProps.elementRef)) {
          _this.props.scrollerProps.elementRef(ref);
        }
      };
      _this.elementRefContent = function(ref) {
        _this.contentElement = ref;
        if (isFun(_this.props.contentProps.elementRef)) {
          _this.props.contentProps.elementRef(ref);
        }
      };
      _this.elementRefTrackX = function(ref) {
        _this.trackXElement = ref;
        if (isFun(_this.props.trackXProps.elementRef)) {
          _this.props.trackXProps.elementRef(ref);
        }
      };
      _this.elementRefTrackY = function(ref) {
        _this.trackYElement = ref;
        if (isFun(_this.props.trackYProps.elementRef)) {
          _this.props.trackYProps.elementRef(ref);
        }
      };
      _this.elementRefThumbX = function(ref) {
        _this.thumbXElement = ref;
        if (isFun(_this.props.thumbXProps.elementRef)) {
          _this.props.thumbXProps.elementRef(ref);
        }
      };
      _this.elementRefThumbY = function(ref) {
        _this.thumbYElement = ref;
        if (isFun(_this.props.thumbYProps.elementRef)) {
          _this.props.thumbYProps.elementRef(ref);
        }
      };
      _this.handleTrackXClick = function(ev, values) {
        if (_this.props.trackXProps.onClick) {
          _this.props.trackXProps.onClick(ev, values);
        }
        if (!_this.scrollerElement || !_this.trackXElement || !_this.thumbXElement || !_this.scrollValues || !_this.scrollValues.scrollXPossible) {
          return;
        }
        _this._scrollDetection();
        var thumbSize = _this.thumbXElement.clientWidth;
        var trackInnerSize = getInnerWidth(_this.trackXElement);
        var thumbOffset = (_this.scrollValues.isRTL && shouldReverseRtlScroll() ? values.offset + thumbSize / 2 - trackInnerSize : values.offset - thumbSize / 2) - (Number.parseFloat(getComputedStyle(_this.trackXElement).paddingLeft) || 0);
        var target = calcScrollForThumbOffset(_this.scrollValues.scrollWidth, _this.scrollValues.clientWidth, trackInnerSize, thumbSize, thumbOffset);
        if (_this.props.trackClickBehavior === TRACK_CLICK_BEHAVIOR.STEP) {
          target = (_this.scrollValues.isRTL ? _this.scrollValues.scrollLeft > target : _this.scrollValues.scrollLeft < target) ? _this.scrollValues.scrollLeft + _this.scrollValues.clientWidth : _this.scrollValues.scrollLeft - _this.scrollValues.clientWidth;
        }
        _this.scrollerElement.scrollLeft = target;
      };
      _this.handleTrackYClick = function(ev, values) {
        if (_this.props.trackYProps.onClick) _this.props.trackYProps.onClick(ev, values);
        if (!_this.scrollerElement || !_this.trackYElement || !_this.thumbYElement || !_this.scrollValues || !_this.scrollValues.scrollYPossible) {
          return;
        }
        _this._scrollDetection();
        var thumbSize = _this.thumbYElement.clientHeight;
        var target = calcScrollForThumbOffset(_this.scrollValues.scrollHeight, _this.scrollValues.clientHeight, getInnerHeight(_this.trackYElement), thumbSize, values.offset - thumbSize / 2) - (Number.parseFloat(getComputedStyle(_this.trackYElement).paddingTop) || 0);
        if (_this.props.trackClickBehavior === TRACK_CLICK_BEHAVIOR.JUMP) {
          _this.scrollerElement.scrollTop = target;
        } else {
          _this.scrollerElement.scrollTop = _this.scrollValues.scrollTop < target ? _this.scrollValues.scrollTop + _this.scrollValues.clientHeight : _this.scrollValues.scrollTop - _this.scrollValues.clientHeight;
        }
      };
      _this.handleTrackYMouseWheel = function(ev) {
        var props2 = _this.props;
        if (props2.trackYProps && props2.trackYProps.onWheel) {
          props2.trackYProps.onWheel(ev);
        }
        if (props2.disableTracksMousewheelScrolling || props2.disableTrackYMousewheelScrolling) {
          return;
        }
        _this._scrollDetection();
        if (!_this.scrollerElement || _this.scrollValues.scrollYBlocked) {
          return;
        }
        _this.scrollTop += ev.deltaY;
      };
      _this.handleTrackXMouseWheel = function(ev) {
        var props2 = _this.props;
        if (props2.trackXProps && props2.trackXProps.onWheel) {
          props2.trackXProps.onWheel(ev);
        }
        if (props2.disableTracksMousewheelScrolling || props2.disableTrackXMousewheelScrolling) {
          return;
        }
        _this._scrollDetection();
        if (!_this.scrollerElement || _this.scrollValues.scrollXBlocked) {
          return;
        }
        _this.scrollLeft += ev.deltaX;
      };
      _this.handleThumbXDrag = function(data) {
        var _a;
        if (!_this.trackXElement || !_this.thumbXElement || !_this.scrollerElement || !_this.scrollValues || !_this.scrollValues.scrollXPossible) {
          return;
        }
        _this._scrollDetection();
        var trackRect = _this.trackXElement.getBoundingClientRect();
        var styles = getComputedStyle(_this.trackXElement);
        var paddingLeft = Number.parseFloat(styles.paddingLeft) || 0;
        var paddingRight = Number.parseFloat(styles.paddingRight) || 0;
        var trackInnerSize = trackRect.width - paddingLeft - paddingRight;
        var thumbSize = _this.thumbXElement.clientWidth;
        var offset = _this.scrollValues.isRTL && shouldReverseRtlScroll() ? data.x + thumbSize - trackInnerSize + paddingLeft : data.lastX - paddingLeft;
        _this.scrollerElement.scrollLeft = calcScrollForThumbOffset(_this.scrollValues.scrollWidth, _this.scrollValues.clientWidth, trackInnerSize, thumbSize, offset);
        if ((_a = _this.props.thumbXProps) === null || _a === void 0 ? void 0 : _a.onDrag) {
          _this.props.thumbXProps.onDrag(data);
        }
      };
      _this.handleThumbXDragEnd = function(data) {
        var _a;
        _this.handleThumbXDrag(data);
        if ((_a = _this.props.thumbXProps) === null || _a === void 0 ? void 0 : _a.onDragEnd) {
          _this.props.thumbXProps.onDragEnd(data);
        }
      };
      _this.handleThumbYDrag = function(data) {
        var _a;
        if (!_this.scrollerElement || !_this.trackYElement || !_this.thumbYElement || !_this.scrollValues || !_this.scrollValues.scrollYPossible) {
          return;
        }
        _this._scrollDetection();
        var trackRect = _this.trackYElement.getBoundingClientRect();
        var styles = getComputedStyle(_this.trackYElement);
        var paddingTop = Number.parseFloat(styles.paddingTop) || 0;
        var paddingBottom = Number.parseFloat(styles.paddingBottom) || 0;
        var trackInnerSize = trackRect.height - paddingTop - paddingBottom;
        var thumbSize = _this.thumbYElement.clientHeight;
        var offset = data.y - paddingTop;
        _this.scrollerElement.scrollTop = calcScrollForThumbOffset(_this.scrollValues.scrollHeight, _this.scrollValues.clientHeight, trackInnerSize, thumbSize, offset);
        if ((_a = _this.props.thumbYProps) === null || _a === void 0 ? void 0 : _a.onDrag) {
          _this.props.thumbYProps.onDrag(data);
        }
      };
      _this.handleThumbYDragEnd = function(data) {
        var _a;
        _this.handleThumbYDrag(data);
        if ((_a = _this.props.thumbYProps) === null || _a === void 0 ? void 0 : _a.onDragEnd) {
          _this.props.thumbYProps.onDragEnd(data);
        }
      };
      _this.handleScrollerScroll = function() {
        _this._scrollDetection();
      };
      _this._scrollDetection = function() {
        if (!_this._scrollDetectionTO) {
          _this.eventEmitter.emit("scrollStart", _this.getScrollState());
        } else if (isBrowser) {
          window.clearTimeout(_this._scrollDetectionTO);
        }
        _this._scrollDetectionTO = isBrowser ? window.setTimeout(_this._scrollDetectionCallback, _this.props.scrollDetectionThreshold || 0) : null;
      };
      _this._scrollDetectionCallback = function() {
        _this._scrollDetectionTO = null;
        _this.eventEmitter.emit("scrollStop", _this.getScrollState());
      };
      _this.state = {
        trackXVisible: false,
        trackYVisible: false,
        isRTL: props.rtl
      };
      _this.scrollValues = _this.getScrollState(true);
      _this.eventEmitter = new Emittr(15);
      if (props.onUpdate) _this.eventEmitter.on("update", props.onUpdate);
      if (props.onScroll) _this.eventEmitter.on("scroll", props.onScroll);
      if (props.onScrollStart) _this.eventEmitter.on("scrollStart", props.onScrollStart);
      if (props.onScrollStop) _this.eventEmitter.on("scrollStop", props.onScrollStop);
      _this.id = uuid();
      return _this;
    }
    Object.defineProperty(Scrollbar2.prototype, "scrollTop", {
      // eslint-disable-next-line react/sort-comp
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.scrollTop;
        }
        return 0;
      },
      set: function set(top) {
        if (this.scrollerElement) {
          this.scrollerElement.scrollTop = top;
          this.update();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "scrollLeft", {
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.scrollLeft;
        }
        return 0;
      },
      set: function set(left) {
        if (this.scrollerElement) {
          this.scrollerElement.scrollLeft = left;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "scrollHeight", {
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.scrollHeight;
        }
        return 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "scrollWidth", {
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.scrollWidth;
        }
        return 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "clientHeight", {
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.clientHeight;
        }
        return 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "clientWidth", {
      get: function get() {
        if (this.scrollerElement) {
          return this.scrollerElement.clientWidth;
        }
        return 0;
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar2.calculateStyles = function(props, state, scrollValues, scrollbarWidth) {
      var _a, _b, _c, _d;
      var useDefaultStyles = !props.noDefaultStyles;
      return {
        holder: __assign(__assign(__assign({}, useDefaultStyles && style.holder), {
          position: "relative"
        }), props.style),
        wrapper: __assign(__assign(__assign({}, useDefaultStyles && __assign(__assign(__assign({}, style.wrapper), !props.disableTracksWidthCompensation && !props.disableTrackYWidthCompensation && (_a = {}, _a[state.isRTL ? "left" : "right"] = state.trackYVisible ? 10 : 0, _a)), !props.disableTracksWidthCompensation && !props.disableTrackXWidthCompensation && {
          bottom: state.trackXVisible ? 10 : 0
        })), props.wrapperProps.style), {
          position: "absolute",
          overflow: "hidden"
        }),
        content: __assign(__assign(__assign(__assign(__assign({}, useDefaultStyles && style.content), props.translateContentSizesToHolder || props.translateContentSizeYToHolder || props.translateContentSizeXToHolder ? {
          display: "table-cell"
        } : {
          padding: 0.05
          // needed to disable margin collapsing without flexboxes, other possible solutions here: https://stackoverflow.com/questions/19718634/how-to-disable-margin-collapsing
        }), useDefaultStyles && !(props.translateContentSizesToHolder || props.translateContentSizeYToHolder) && {
          minHeight: "100%"
        }), useDefaultStyles && !(props.translateContentSizesToHolder || props.translateContentSizeXToHolder) && {
          minWidth: "100%"
        }), props.contentProps.style),
        scroller: __assign(__assign(__assign(__assign((_b = {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          paddingBottom: !scrollbarWidth && scrollValues.scrollXPossible ? props.fallbackScrollbarWidth : void 0
        }, _b[state.isRTL ? "paddingLeft" : "paddingRight"] = !scrollbarWidth && scrollValues.scrollYPossible ? props.fallbackScrollbarWidth : void 0, _b), props.scrollerProps.style), !isUndef(props.rtl) && {
          direction: props.rtl ? "rtl" : "ltr"
        }), props.momentum && {
          WebkitOverflowScrolling: "touch"
        }), (_c = {
          overflowY: scrollValues.scrollYPossible ? "scroll" : "hidden",
          overflowX: scrollValues.scrollXPossible ? "scroll" : "hidden",
          marginBottom: scrollValues.scrollXPossible ? -(scrollbarWidth || props.fallbackScrollbarWidth) - Number(scrollValues.zoomLevel !== 1) : void 0
        }, _c[state.isRTL ? "marginLeft" : "marginRight"] = scrollValues.scrollYPossible ? -(scrollbarWidth || props.fallbackScrollbarWidth) - Number(scrollValues.zoomLevel !== 1) : void 0, _c)),
        trackX: __assign(__assign(__assign(__assign({}, useDefaultStyles && style.track.common), useDefaultStyles && style.track.x), props.trackXProps.style), !state.trackXVisible && {
          display: "none"
        }),
        trackY: __assign(__assign(__assign(__assign(__assign({}, useDefaultStyles && style.track.common), useDefaultStyles && style.track.y), useDefaultStyles && (_d = {}, _d[state.isRTL ? "left" : "right"] = 0, _d)), props.trackYProps.style), !state.trackYVisible && {
          display: "none"
        }),
        thumbX: __assign(__assign(__assign({}, useDefaultStyles && style.thumb.common), useDefaultStyles && style.thumb.x), props.thumbXProps.style),
        thumbY: __assign(__assign(__assign({}, useDefaultStyles && style.thumb.common), useDefaultStyles && style.thumb.y), props.thumbYProps.style)
      };
    };
    Scrollbar2.prototype.componentDidMount = function() {
      if (!this.scrollerElement) {
        this.setState(function() {
          throw new Error("scroller element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
        });
        return;
      }
      if (!this.contentElement) {
        this.setState(function() {
          throw new Error("content element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
        });
        return;
      }
      var props = this.props;
      if (!props.native && !props.mobileNative) {
        if (!this.holderElement) {
          this.setState(function() {
            throw new Error("holder element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
          });
          return;
        }
        if (!this.wrapperElement) {
          this.setState(function() {
            throw new Error("wrapper element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
          });
          return;
        }
      }
      Loop.addTarget(this);
      if (!isUndef(props.scrollTop)) {
        this.scrollerElement.scrollTop = props.scrollTop;
      }
      if (!isUndef(props.scrollLeft)) {
        this.scrollerElement.scrollLeft = props.scrollLeft;
      }
      this.update(true);
    };
    Scrollbar2.prototype.componentWillUnmount = function() {
      Loop.removeTarget(this);
    };
    Scrollbar2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (!this.scrollerElement) {
        return;
      }
      var props = this.props;
      if (props.rtl !== prevProps.rtl && props.rtl !== this.state.isRTL) {
        this.setState({
          isRTL: props.rtl
        });
      }
      if (this.state.isRTL !== prevState.isRTL) {
        this.update();
      }
      if (!isUndef(props.scrollTop) && props.scrollTop !== this.scrollerElement.scrollTop) {
        this.scrollerElement.scrollTop = props.scrollTop;
      }
      if (!isUndef(props.scrollLeft) && props.scrollLeft !== this.scrollerElement.scrollLeft) {
        this.scrollerElement.scrollLeft = props.scrollLeft;
      }
      if (prevProps.onUpdate !== props.onUpdate) {
        if (prevProps.onUpdate) this.eventEmitter.off("update", prevProps.onUpdate);
        if (props.onUpdate) this.eventEmitter.on("update", props.onUpdate);
      }
      if (prevProps.onScroll !== props.onScroll) {
        if (prevProps.onScroll) this.eventEmitter.off("scroll", prevProps.onScroll);
        if (props.onScroll) this.eventEmitter.on("scroll", props.onScroll);
      }
      if (prevProps.onScrollStart !== props.onScrollStart) {
        if (prevProps.onScrollStart) this.eventEmitter.off("scrollStart", prevProps.onScrollStart);
        if (props.onScrollStart) this.eventEmitter.on("scrollStart", props.onScrollStart);
      }
      if (prevProps.onScrollStop !== props.onScrollStop) {
        if (prevProps.onScrollStop) this.eventEmitter.off("scrollStop", prevProps.onScrollStop);
        if (props.onScrollStop) this.eventEmitter.on("scrollStop", props.onScrollStop);
      }
    };
    Scrollbar2.prototype.render = function() {
      var _a = this.props, createContext2 = _a.createContext, rtl = _a.rtl, native = _a.native, mobileNative = _a.mobileNative, momentum = _a.momentum;
      _a.noDefaultStyles;
      var disableTracksMousewheelScrolling = _a.disableTracksMousewheelScrolling, disableTrackXMousewheelScrolling = _a.disableTrackXMousewheelScrolling, disableTrackYMousewheelScrolling = _a.disableTrackYMousewheelScrolling;
      _a.disableTracksWidthCompensation;
      _a.disableTrackXWidthCompensation;
      _a.disableTrackYWidthCompensation;
      var noScrollX = _a.noScrollX, noScrollY = _a.noScrollY, noScroll = _a.noScroll, permanentTrackX = _a.permanentTrackX, permanentTrackY = _a.permanentTrackY, permanentTracks = _a.permanentTracks, removeTracksWhenNotUsed = _a.removeTracksWhenNotUsed, removeTrackYWhenNotUsed = _a.removeTrackYWhenNotUsed, removeTrackXWhenNotUsed = _a.removeTrackXWhenNotUsed;
      _a.minimalThumbSize;
      _a.maximalThumbSize;
      _a.minimalThumbXSize;
      _a.maximalThumbXSize;
      _a.minimalThumbYSize;
      _a.maximalThumbYSize;
      _a.fallbackScrollbarWidth;
      _a.scrollTop;
      _a.scrollLeft;
      _a.trackClickBehavior;
      _a.scrollDetectionThreshold;
      var propsWrapperProps = _a.wrapperProps, propsScrollerProps = _a.scrollerProps, propsContentProps = _a.contentProps, propsTrackXProps = _a.trackXProps, propsTrackYProps = _a.trackYProps, propsThumbXProps = _a.thumbXProps, propsThumbYProps = _a.thumbYProps, propsScrollbarWidth = _a.scrollbarWidth;
      _a.elementRef;
      _a.onUpdate;
      _a.onScroll;
      _a.onScrollStart;
      _a.onScrollStop;
      _a.translateContentSizesToHolder;
      _a.translateContentSizeYToHolder;
      _a.translateContentSizeXToHolder;
      var children = _a.children, propsHolderProps = __rest(_a, ["createContext", "rtl", "native", "mobileNative", "momentum", "noDefaultStyles", "disableTracksMousewheelScrolling", "disableTrackXMousewheelScrolling", "disableTrackYMousewheelScrolling", "disableTracksWidthCompensation", "disableTrackXWidthCompensation", "disableTrackYWidthCompensation", "noScrollX", "noScrollY", "noScroll", "permanentTrackX", "permanentTrackY", "permanentTracks", "removeTracksWhenNotUsed", "removeTrackYWhenNotUsed", "removeTrackXWhenNotUsed", "minimalThumbSize", "maximalThumbSize", "minimalThumbXSize", "maximalThumbXSize", "minimalThumbYSize", "maximalThumbYSize", "fallbackScrollbarWidth", "scrollTop", "scrollLeft", "trackClickBehavior", "scrollDetectionThreshold", "wrapperProps", "scrollerProps", "contentProps", "trackXProps", "trackYProps", "thumbXProps", "thumbYProps", "scrollbarWidth", "elementRef", "onUpdate", "onScroll", "onScrollStart", "onScrollStop", "translateContentSizesToHolder", "translateContentSizeYToHolder", "translateContentSizeXToHolder", "children"]);
      var scrollbarWidth = !isUndef(propsScrollbarWidth) ? propsScrollbarWidth : getScrollbarWidth() || 0;
      if (native || !scrollbarWidth && mobileNative) {
        this.elementRefHolder(null);
        this.elementRefWrapper(null);
        this.elementRefTrackX(null);
        this.elementRefTrackY(null);
        this.elementRefThumbX(null);
        this.elementRefThumbY(null);
        var contentProps_1 = __assign(__assign({}, propsContentProps), {
          key: "ScrollbarsCustom-Content",
          className: cnb("ScrollbarsCustom-Content", propsContentProps.className),
          children
        });
        var scrollerProps_1 = __assign(__assign({}, propsHolderProps), {
          className: cnb("ScrollbarsCustom native", this.state.trackYVisible && "trackYVisible", this.state.trackXVisible && "trackXVisible", this.state.isRTL && "rtl", propsHolderProps.className),
          style: __assign(__assign(__assign(__assign({}, propsHolderProps.style), !isUndef(rtl) && {
            direction: rtl ? "rtl" : "ltr"
          }), momentum && {
            WebkitOverflowScrolling: "touch"
          }), {
            overflowX: noScroll || noScrollX ? "hidden" : permanentTracks || permanentTrackX ? "scroll" : "auto",
            overflowY: noScroll || noScrollY ? "hidden" : permanentTracks || permanentTrackY ? "scroll" : "auto"
          }),
          onScroll: this.handleScrollerScroll,
          children: renderDivWithRenderer(contentProps_1, this.elementRefContent),
          renderer: propsScrollerProps.renderer,
          elementRef: propsScrollerProps.elementRef
        });
        return renderDivWithRenderer(scrollerProps_1, this.elementRefScroller);
      }
      var styles = Scrollbar2.calculateStyles(this.props, this.state, this.scrollValues, scrollbarWidth);
      var holderChildren = [];
      var contentProps = __assign(__assign({}, propsContentProps), {
        key: "ScrollbarsCustom-Content",
        className: cnb("ScrollbarsCustom-Content", propsContentProps.className),
        style: styles.content,
        children: createContext2 ? (
          // eslint-disable-next-line react/jsx-no-constructed-context-values
          React.createElement(ScrollbarContext.Provider, {
            value: {
              parentScrollbar: this
            }
          }, children)
        ) : children
      });
      var scrollerProps = __assign(__assign({}, propsScrollerProps), {
        key: "ScrollbarsCustom-Scroller",
        className: cnb("ScrollbarsCustom-Scroller", propsScrollerProps.className),
        style: styles.scroller,
        children: renderDivWithRenderer(contentProps, this.elementRefContent),
        onScroll: this.handleScrollerScroll
      });
      var wrapperProps = __assign(__assign({}, propsWrapperProps), {
        key: "ScrollbarsCustom-Wrapper",
        className: cnb("ScrollbarsCustom-Wrapper", propsWrapperProps.className),
        style: styles.wrapper,
        children: renderDivWithRenderer(scrollerProps, this.elementRefScroller)
      });
      holderChildren.push(renderDivWithRenderer(wrapperProps, this.elementRefWrapper));
      if (this.state.trackYVisible || !removeTracksWhenNotUsed && !removeTrackYWhenNotUsed) {
        var thumbYProps = __assign(__assign({}, propsThumbYProps), {
          key: "ScrollbarsCustom-ThumbY",
          style: styles.thumbY,
          elementRef: this.elementRefThumbY,
          onDrag: this.handleThumbYDrag,
          onDragEnd: this.handleThumbYDragEnd,
          axis: AXIS_DIRECTION.Y
        });
        var trackYProps = __assign(__assign(__assign(__assign({}, propsTrackYProps), {
          key: "ScrollbarsCustom-TrackY",
          style: styles.trackY,
          elementRef: this.elementRefTrackY,
          onClick: this.handleTrackYClick
        }), (disableTracksMousewheelScrolling || disableTrackYMousewheelScrolling) && {
          onWheel: this.handleTrackYMouseWheel
        }), {
          axis: AXIS_DIRECTION.Y
        });
        trackYProps.children = React.createElement(ScrollbarThumb, __assign({}, thumbYProps));
        holderChildren.push(React.createElement(ScrollbarTrack, __assign({}, trackYProps)));
      } else {
        this.elementRefTrackY(null);
        this.elementRefThumbY(null);
      }
      if (this.state.trackXVisible || !removeTracksWhenNotUsed && !removeTrackXWhenNotUsed) {
        var thumbXProps = __assign(__assign({}, propsThumbXProps), {
          key: "ScrollbarsCustom-ThumbX",
          style: styles.thumbX,
          elementRef: this.elementRefThumbX,
          onDrag: this.handleThumbXDrag,
          onDragEnd: this.handleThumbXDragEnd,
          axis: AXIS_DIRECTION.X
        });
        var trackXProps = __assign(__assign(__assign(__assign({}, propsTrackXProps), {
          key: "ScrollbarsCustom-TrackX",
          style: styles.trackX,
          elementRef: this.elementRefTrackX,
          onClick: this.handleTrackXClick
        }), (disableTracksMousewheelScrolling || disableTrackXMousewheelScrolling) && {
          onWheel: this.handleTrackXMouseWheel
        }), {
          axis: AXIS_DIRECTION.X
        });
        trackXProps.children = React.createElement(ScrollbarThumb, __assign({}, thumbXProps));
        holderChildren.push(React.createElement(ScrollbarTrack, __assign({}, trackXProps)));
      } else {
        this.elementRefTrackX(null);
        this.elementRefThumbX(null);
      }
      var holderProps = __assign(__assign({}, propsHolderProps), {
        className: cnb("ScrollbarsCustom", this.state.trackYVisible && "trackYVisible", this.state.trackXVisible && "trackXVisible", this.state.isRTL && "rtl", propsHolderProps.className),
        style: styles.holder,
        children: holderChildren
      });
      return renderDivWithRenderer(holderProps, this.elementRefHolder);
    };
    Scrollbar2.contextType = ScrollbarContext;
    Scrollbar2.defaultProps = {
      momentum: true,
      minimalThumbSize: 30,
      fallbackScrollbarWidth: 20,
      trackClickBehavior: TRACK_CLICK_BEHAVIOR.JUMP,
      scrollDetectionThreshold: 100,
      wrapperProps: {},
      scrollerProps: {},
      contentProps: {},
      trackXProps: {},
      trackYProps: {},
      thumbXProps: {},
      thumbYProps: {}
    };
    return Scrollbar2;
  }(React.Component)
);
export {
  Scrollbar,
  ScrollbarContext,
  Scrollbar as default
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-scrollbars-custom.js.map
